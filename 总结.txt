1.什么是分布式事务
	在多个微服务之间，需要保证不同的数据库之间操作要么同时成功要么同时失败

2.应用架构的演变

3.springcloud概述：是微服务思想的落地方案，提供了微服务的一站式解决方案

4.springcloud中的组件
	1.注册中心
		1.nacos         alibaba
		2.eureka
	2.网关
		1.gateway
		2.zuul
	3.熔断器
		1.hystrix
		2.sentinel         alibaba
	4.负载均衡&调用
		1.ribbon
		2.openfeign
	5.配置中心
		1.config
		2.nacos         alibaba

5.Eureka
	1.概述：是一个注册中心，所有的微服务都需要注册进入Eureka中
	2.服务端搭建
		1.导入Eureka服务端依赖
		2.启动类加上@EnableEurekaServer
		3.yml配置
			1.端口号
			2.注册中心地址
			3.关闭服务发现
			4.关闭服务注册
			5.自己的服务名称
	3.客户端搭建
		1.导入Eureka客户端依赖
		2.启动类加上@EnableEurekaClient注解
		3.yml配置
			1.端口号
			2.应用名称
			3.注册中心地址
			4.开启IP地址注册
			5.实例ID

6.springcloud父子项目搭建步骤
	1.创建父工厂，删除src
	2.导入父依赖
		1.spring-boot-parent
		2.springcloud依赖
		3.junit&lombok看情况而定，如果全局需要使用就导入
	3.搭建其他微服务

7.Ribbon+RestTemp
	1.RestTemplate
		1.在启动类中使用@Bean注解方式创建RestTemplate对象，注意方法名称必须是restTemplate
		2.在需要使用的地方注入RestTemplate即可，在方法中直接调用
	2.Ribbon
		1.导入依赖
		2.在RestTemplate实例方法上加上负载均衡注解
		3.在调用时不要使用IP+Port，使用对应微服务的应用名称

1.OpenFeign
	1.概述：OpenFeign底层整合了RestTemplate、Ribbon、Hystrix，可以帮助我们做负载均衡调用
	2.使用
		1.导入依赖
		2.启动类加上@EnableFeignClients
		3.创建feign接口，在接口上加上@FeignClent(value="被调用的服务名称")
		4.在feign接口中，复制要调用的微服务的接口方法，把方法体删除
		5.在需要调用的地方，注入feign接口，像调用方法一样的调用接口
		6.真实开发时，建议打开feign接口日志，具体百度

2.Hystrix
	1.概述：熔断器，可以防止服务雪崩
	2.设计规则
		1.服务熔断：当服务持续不可调用时，Hystrix会将此服务进行熔断，也就是不可调用了
		2.快速响应：当服务熔断之后我们还需要快速响应请求，避免请求堵塞影响其他服务
		3.服务降级：当我们请求快速响应之后，我们需要有对应的托底数据，快速响应给用户
		4.服务监控：我们可以看到整个服务的熔断情况
	3.功能
		1.服务熔断
		2.服务降级
		3.缓存：当参数一致时，响应上一次的请求结果
		4.资源隔离：
			1.为什么需要资源隔离：我们不能将所有的请求全部放进来，这样会把微服务给整崩盘
			2.什么是资源隔离：限流，限制请求数
			3.模式：
				1.线程池模式：新来的请求会分配一个线程去处理请求，最大的并发数就是线程数量+排队数量
				2.信号量模式：来了一个请求计数+1，出去一个请求计数-1，当并发量达到设置的最大信号量的时候，直接拒绝，最高
					并发量就是信号量最大数
	4.工作机制
		1.正常：服务一开始就是正常状态
		2.熔断：当服务持续几次都不可以用时，进入熔断状态
		3.半熔断：进入熔断状态之后5S之后会进入半熔断，会允许少量请求进来尝试，如果成功恢复正常，如果失败还是熔断状态
3.Ribbon整合Hystrix
	1.在调用方导入hystrix依赖
	2.在类上加上一个@Enable断路器
	3.在需要熔断的接口方法上加上一个@HystrixCommand(fallbackMethod = "熔断方法名称")
	4.在本类编写一个熔断方法，方法的返回值和参数必须跟接口一致，方法名称就是fallbackMethod的名称
4.OpenFeign整合Hystrix
	1.在服务的调用方开启hystrix熔断器
	2.在openFeign接口的@FeignClient接口中指定fallbackFactory属性，指定为你的降级工厂类的字节码
	3.创建熔断类，实现FallbackFactory泛型就是openFeign接口，必须交给spring管理，实现方法，在方法中
		返回我们openFeign接口的对象，对象中的方法就是熔断方法，返回的数据就是托底数据

1.Zuul
	1.概述：是微服务的大门，是一个网关，我们可以在网关层做鉴权、登录、熔断...
	2.使用
		1.搭建一个Zuul的Eureka客户端
		2.导入Jar包
		3.启动类加注解@EnableZuulProxy，开启Zuul网关
		4.yml配置
			1.统一访问前缀
			2.禁用服务名称访问服务
			3.配置服务的路由
2.Gateway
	1.概述：是微服务的大门，是一个网关，我们可以在网关层做鉴权、登录、熔断...spring自己的
	2.原理
		1.请求进来之后会交给HandlerMapping处理器映射器处理请求
		2.处理器映射器会根据请求地址找到handler处理器，handler会处理请求
		3.请求在进入微服务之前，会经过一系列的filter，不管是局部还是全局的，并且在返回的时候也会经过所有
			filter调用链进行响应
	3.使用
		1.导入Jar包，不需要导入springboot-web包
		2.启动类加上@EnableDiscoveryClient，此注解代表是注册中心客户端，所有注册中心都可以用
		3.编写yml
			1.关闭服务名称访问
			2.开启服务名称小写访问
			3.配置微服务的路由
3.Config
	1.为什么需要：我们的微服务配置众多，为了方便统一管理，我们会将所有的配置文件放在配置中心中统一管理
	2.原理
		1.config配置中心在启动时会拉取我们指定的git上的配置
		2.其他服务在启动时会连接到config配置中心获取到自己指定的配置文件
	3.关系
		1.config配置中心也是一个eureka客户端
		2.所有把配置文件交给config管理的微服务都是config的客户端
	4.springboot项目配置文件执行顺序
		1.springboot项目在启动时必须有application.yml配置文件，会根据里面的配置进行启动
		2.bootstrap.yml，他的执行时机比application.yml更高，有更多的时机给我们去拉取配置文件
		3.如果远程注册中心中有application.yml并且本地也有application.yml那么配置会做合并，以远程为准
	5.config服务端搭建
		1.创建远程仓库，把配置文件名称改为application-服务名称-环境名称.yml
		2.上传配置文件到远程仓库
		3.导入config-server依赖
		4.启动类上加上@EnableConfigServer注解
		5.在yml中指定git地址
	6.config客户端搭建
		1.导入config.client依赖
		2.创建一个bootstrap.yml配置文件
			1.配置中心路径
			2.配置文件名称
			3.配置文件最后一个-所指定的环境
			4.分支，默认就是master，可以不写

alibaba
1.springcloudalibba概述：是springcloud第二代解决方案，是ali旗下开发的微服务一站式解决方案
2.Nacos注册中心
    1.概述：跟Eureka一样
    2.使用
        1.去官网下载压缩包，解压使用命令启动
        2.微服务客户端注册
            1.导入依赖
            2.启动类加上注解
            3.yml
                1.端口号
                2.注册中心地址
                3.应用名称
3.Nacos配置中心
    1.概述：跟config一样
    2.使用
        1.导入依赖
        2.去nacos配置中心中给自己的微服务添加一个yaml配置
        3.在微服务中创建一个bootstrap.yml，指定配置中心配置文件配置
            1.配置中心地址
            2.后缀
            3.文件名称
            4.环境
            5.分组
            6.命名空间，如果在Public就不用写
4.Sentinel
    1.sentinel限流
        1.概述：限制请求能够进来的数量
        2.使用
            1.下载sentinel的Jar包，使用命令启动
            2.需要限流的微服务中
                1.导入依赖
                2.在需要限流的接口上加上注解
                    1.在注解中可以指定限流的降级方法
                    2.必须配置value，给当前接口取一个资源名称
                3.yml配置sentinel服务地址
            3.在sentinel服务中可以配置限流规则，查看效果
            4.Sentinel规则持久化到Nacos中
                1.导入sentinel和nacos的整合依赖
                2.在配置中心中创建规则的配置文件
                3.在微服务中指定需要拉取的限流规则
                    1.持久化地址
                    2.配置文件名称
                    3.分组
                    4.配置文件类型：限流/熔断
    2.sentinel熔断
        1.概述：当微服务发生异常、错误、响应忙等，那么会触发熔断
        2.使用
            1.导入依赖
            2.在需要熔断的接口上加上熔断注解，在熔断注解中可以指定fallback，指定降级方法
            3.也可以在sentinel中配置熔断规则
    3.OpenFeign整合sentinel
        1.导入openfeign&sentinel依赖
        2.yml开启熔断功能
        3.在feign接口上的@FeignClient注解中，指定熔断降级方法